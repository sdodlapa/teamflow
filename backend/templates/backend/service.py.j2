"""
{{ entity.name }} Service
Generated on: {{ today() }}
Domain: {{ domain.name }}
"""

from typing import List, Optional, Dict, Any, Tuple
from uuid import UUID

from sqlalchemy import select, func, or_, and_
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload

from app.models.{{ entity.name | snake_case }} import {{ entity.name | camel_case }}
from app.schemas.{{ entity.name | snake_case }} import (
    {{ entity.name | camel_case }}Create,
    {{ entity.name | camel_case }}Update
)
from app.core.exceptions import NotFoundError, ValidationError


class {{ entity.name | camel_case }}Service:
    """Service class for {{ entity.name | camel_case }} operations."""
    
    async def list_{{ entity.name | snake_case | plural }}(
        self,
        db: AsyncSession,
        skip: int = 0,
        limit: int = 20,
        filters: Optional[Dict[str, Any]] = None,
        search: Optional[str] = None
    ) -> Tuple[List[{{ entity.name | camel_case }}], int]:
        """
        List {{ entity.name | snake_case | plural }} with pagination, filtering, and search.
        
        Args:
            db: Database session
            skip: Number of records to skip
            limit: Maximum number of records to return
            filters: Dictionary of filters to apply
            search: Search term for full-text search
            
        Returns:
            Tuple of ({{ entity.name | snake_case | plural }}, total_count)
        """
        query = select({{ entity.name | camel_case }})
        count_query = select(func.count({{ entity.name | camel_case }}.id))
        
        # Apply filters
        if filters:
            filter_conditions = []
            for key, value in filters.items():
                if hasattr({{ entity.name | camel_case }}, key) and value is not None:
                    filter_conditions.append(getattr({{ entity.name | camel_case }}, key) == value)
            
            if filter_conditions:
                query = query.where(and_(*filter_conditions))
                count_query = count_query.where(and_(*filter_conditions))
        
        # Apply search
        if search:
            search_conditions = []
            {% if entity.searchable_fields %}
            # Search in specified searchable fields
            {% for field in entity.searchable_fields %}
            {% if field.type == 'string' or field.type == 'text' %}
            search_conditions.append({{ entity.name | camel_case }}.{{ field.name }}.ilike(f"%{search}%"))
            {% endif %}
            {% endfor %}
            {% else %}
            # Default search in common text fields
            {% for field in entity.fields %}
            {% if field.type == 'string' or field.type == 'text' %}
            search_conditions.append({{ entity.name | camel_case }}.{{ field.name }}.ilike(f"%{search}%"))
            {% endif %}
            {% endfor %}
            {% endif %}
            
            if search_conditions:
                search_filter = or_(*search_conditions)
                query = query.where(search_filter)
                count_query = count_query.where(search_filter)
        
        # Apply ordering
        {% if entity.default_sort %}
        query = query.order_by({{ entity.name | camel_case }}.{{ entity.default_sort.field }}{% if entity.default_sort.direction == 'desc' %}.desc(){% endif %})
        {% else %}
        query = query.order_by({{ entity.name | camel_case }}.created_at.desc())
        {% endif %}
        
        # Apply pagination
        query = query.offset(skip).limit(limit)
        
        # Execute queries
        result = await db.execute(query)
        {{ entity.name | snake_case | plural }} = result.scalars().all()
        
        count_result = await db.execute(count_query)
        total = count_result.scalar()
        
        return {{ entity.name | snake_case | plural }}, total or 0
    
    async def get_{{ entity.name | snake_case }}(
        self, 
        db: AsyncSession, 
        {{ entity.name | snake_case }}_id: UUID,
        load_relationships: bool = False
    ) -> Optional[{{ entity.name | camel_case }}]:
        """
        Get a {{ entity.name | snake_case }} by ID.
        
        Args:
            db: Database session
            {{ entity.name | snake_case }}_id: {{ entity.name | camel_case }} ID
            load_relationships: Whether to load related objects
            
        Returns:
            {{ entity.name | camel_case }} instance or None if not found
        """
        query = select({{ entity.name | camel_case }}).where({{ entity.name | camel_case }}.id == {{ entity.name | snake_case }}_id)
        
        {% if entity.relationships and load_relationships %}
        # Load relationships if requested
        query = query.options(
            {% for rel in entity.relationships %}
            selectinload({{ entity.name | camel_case }}.{{ rel.name }}),
            {% endfor %}
        )
        {% endif %}
        
        result = await db.execute(query)
        return result.scalar_one_or_none()
    
    async def create_{{ entity.name | snake_case }}(
        self,
        db: AsyncSession,
        {{ entity.name | snake_case }}_create: {{ entity.name | camel_case }}Create,
        created_by: Optional[UUID] = None
    ) -> {{ entity.name | camel_case }}:
        """
        Create a new {{ entity.name | snake_case }}.
        
        Args:
            db: Database session
            {{ entity.name | snake_case }}_create: {{ entity.name | camel_case }} creation data
            created_by: ID of the user creating the {{ entity.name | snake_case }}
            
        Returns:
            Created {{ entity.name | camel_case }} instance
        """
        # Validate data
        await self._validate_{{ entity.name | snake_case }}_create(db, {{ entity.name | snake_case }}_create)
        
        # Create model instance
        {{ entity.name | snake_case }}_data = {{ entity.name | snake_case }}_create.model_dump(exclude_unset=True)
        {% if 'created_by' in entity.fields | map(attribute='name') %}
        if created_by:
            {{ entity.name | snake_case }}_data["created_by"] = created_by
        {% endif %}
        
        {{ entity.name | snake_case }} = {{ entity.name | camel_case }}(**{{ entity.name | snake_case }}_data)
        
        db.add({{ entity.name | snake_case }})
        await db.commit()
        await db.refresh({{ entity.name | snake_case }})
        
        return {{ entity.name | snake_case }}
    
    async def update_{{ entity.name | snake_case }}(
        self,
        db: AsyncSession,
        {{ entity.name | snake_case }}: {{ entity.name | camel_case }},
        {{ entity.name | snake_case }}_update: {{ entity.name | camel_case }}Update
    ) -> {{ entity.name | camel_case }}:
        """
        Update an existing {{ entity.name | snake_case }}.
        
        Args:
            db: Database session
            {{ entity.name | snake_case }}: {{ entity.name | camel_case }} instance to update
            {{ entity.name | snake_case }}_update: Update data
            
        Returns:
            Updated {{ entity.name | camel_case }} instance
        """
        # Validate update data
        await self._validate_{{ entity.name | snake_case }}_update(db, {{ entity.name | snake_case }}, {{ entity.name | snake_case }}_update)
        
        # Apply updates
        update_data = {{ entity.name | snake_case }}_update.model_dump(exclude_unset=True)
        for field, value in update_data.items():
            setattr({{ entity.name | snake_case }}, field, value)
        
        await db.commit()
        await db.refresh({{ entity.name | snake_case }})
        
        return {{ entity.name | snake_case }}
    
    async def delete_{{ entity.name | snake_case }}(
        self, 
        db: AsyncSession, 
        {{ entity.name | snake_case }}: {{ entity.name | camel_case }}
    ) -> None:
        """
        Delete a {{ entity.name | snake_case }}.
        
        Args:
            db: Database session
            {{ entity.name | snake_case }}: {{ entity.name | camel_case }} instance to delete
        """
        {% if entity.soft_delete %}
        # Soft delete - mark as inactive
        {{ entity.name | snake_case }}.is_active = False
        await db.commit()
        {% else %}
        # Hard delete
        await db.delete({{ entity.name | snake_case }})
        await db.commit()
        {% endif %}
    
    {% if entity.bulk_operations %}
    async def bulk_create_{{ entity.name | snake_case | plural }}(
        self,
        db: AsyncSession,
        {{ entity.name | snake_case | plural }}_create: List[{{ entity.name | camel_case }}Create],
        created_by: Optional[UUID] = None
    ) -> List[{{ entity.name | camel_case }}]:
        """
        Create multiple {{ entity.name | snake_case | plural }} in a single transaction.
        
        Args:
            db: Database session
            {{ entity.name | snake_case | plural }}_create: List of {{ entity.name | camel_case }} creation data
            created_by: ID of the user creating the {{ entity.name | snake_case | plural }}
            
        Returns:
            List of created {{ entity.name | camel_case }} instances
        """
        {{ entity.name | snake_case | plural }} = []
        
        for {{ entity.name | snake_case }}_create in {{ entity.name | snake_case | plural }}_create:
            # Validate each item
            await self._validate_{{ entity.name | snake_case }}_create(db, {{ entity.name | snake_case }}_create)
            
            # Create model instance
            {{ entity.name | snake_case }}_data = {{ entity.name | snake_case }}_create.model_dump(exclude_unset=True)
            {% if 'created_by' in entity.fields | map(attribute='name') %}
            if created_by:
                {{ entity.name | snake_case }}_data["created_by"] = created_by
            {% endif %}
            
            {{ entity.name | snake_case }} = {{ entity.name | camel_case }}(**{{ entity.name | snake_case }}_data)
            {{ entity.name | snake_case | plural }}.append({{ entity.name | snake_case }})
        
        db.add_all({{ entity.name | snake_case | plural }})
        await db.commit()
        
        # Refresh all instances
        for {{ entity.name | snake_case }} in {{ entity.name | snake_case | plural }}:
            await db.refresh({{ entity.name | snake_case }})
        
        return {{ entity.name | snake_case | plural }}
    {% endif %}
    
    # Validation methods
    async def _validate_{{ entity.name | snake_case }}_create(
        self,
        db: AsyncSession,
        {{ entity.name | snake_case }}_create: {{ entity.name | camel_case }}Create
    ) -> None:
        """Validate {{ entity.name | snake_case }} creation data."""
        {% if entity.unique_constraints %}
        # Check unique constraints
        {% for constraint in entity.unique_constraints %}
        {% if constraint | length == 1 %}
        # Single field uniqueness check
        field_name = "{{ constraint[0] }}"
        field_value = getattr({{ entity.name | snake_case }}_create, field_name)
        if field_value:
            existing = await db.execute(
                select({{ entity.name | camel_case }}).where(
                    getattr({{ entity.name | camel_case }}, field_name) == field_value
                )
            )
            if existing.scalar_one_or_none():
                raise ValidationError(f"{{ constraint[0] | title }} already exists")
        {% else %}
        # Multi-field uniqueness check
        conditions = []
        {% for field in constraint %}
        field_value = getattr({{ entity.name | snake_case }}_create, "{{ field }}")
        if field_value:
            conditions.append({{ entity.name | camel_case }}.{{ field }} == field_value)
        {% endfor %}
        
        if conditions:
            existing = await db.execute(
                select({{ entity.name | camel_case }}).where(and_(*conditions))
            )
            if existing.scalar_one_or_none():
                raise ValidationError("Combination of {{ constraint | join(', ') }} already exists")
        {% endif %}
        {% endfor %}
        {% endif %}
    
    async def _validate_{{ entity.name | snake_case }}_update(
        self,
        db: AsyncSession,
        {{ entity.name | snake_case }}: {{ entity.name | camel_case }},
        {{ entity.name | snake_case }}_update: {{ entity.name | camel_case }}Update
    ) -> None:
        """Validate {{ entity.name | snake_case }} update data."""
        {% if entity.unique_constraints %}
        # Check unique constraints for updated fields
        update_data = {{ entity.name | snake_case }}_update.model_dump(exclude_unset=True)
        
        {% for constraint in entity.unique_constraints %}
        {% if constraint | length == 1 %}
        # Single field uniqueness check
        field_name = "{{ constraint[0] }}"
        if field_name in update_data:
            field_value = update_data[field_name]
            if field_value and field_value != getattr({{ entity.name | snake_case }}, field_name):
                existing = await db.execute(
                    select({{ entity.name | camel_case }}).where(
                        and_(
                            getattr({{ entity.name | camel_case }}, field_name) == field_value,
                            {{ entity.name | camel_case }}.id != {{ entity.name | snake_case }}.id
                        )
                    )
                )
                if existing.scalar_one_or_none():
                    raise ValidationError(f"{{ constraint[0] | title }} already exists")
        {% endif %}
        {% endfor %}
        {% endif %}